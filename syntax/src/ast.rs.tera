{# THIS File is not automatically generated:
the below applies to the result of this template
#}
// This file is automatically generated based on the file `./generated.rs.tera` when `hawthorn::generate` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borowed mode, and only
//! this mode has all AST accessors.
#![allow(bad_style, missing_docs, unreachable_pub)]

use crate::traits::{AstNode,self,child_opt,children};
use crate::SyntaxNode;
use SyntaxKind::*;
/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.
#[derive(Debug,Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
pub enum SyntaxKind {
    // Technical SyntaxKinds: they appear temporally during parsing,
    // but never end up in the final tree
    #[doc(hidden)]
    EOF,

{%- for t in concat(a=single_byte_tokens, b=multi_byte_tokens) %}
    {{t.1}}, // {{t.0}} {{loop.index0}}
{%- endfor -%}
{% for kw in concat(a=keywords) %}
    {{kw | upper}}_KW, // {{kw}} {{loop.index0 + 38 }}
{%- endfor -%}
{% for t in concat(a=literals, b=tokens, c=nodes) %}
    {{t}}, // {{loop.index0 + 63 }}
{%- endfor %}
    // Technical kind so that we can cast from u16 safely
    #[doc(hidden)]
    __LAST,
}


impl From<SyntaxKind> for rowan::SyntaxKind {
    fn from(kind: SyntaxKind) -> Self {
        Self(kind as u16)
    }
}


impl SyntaxKind {
    pub fn text(&self) -> &'static str {
        use SyntaxKind::*;
        match self {
        {%- for t in concat(a=single_byte_tokens, b=multi_byte_tokens) %}
            {{t.1}} => "{{t.0}}",
        {%- endfor -%}
        {% for kw in concat(a=keywords) %}
            {{kw | upper}}_KW => "{{kw}}",
        {%- endfor -%}
        {% for t in concat(a=literals, b=tokens, c=nodes) %}
            {{t}} => "{{t}}",
        {%- endfor %}
        
            _ => ""
        }
    }

    pub fn is_trivia(&self) -> bool {
        use SyntaxKind::*;
        match self {
            COMMENT | WHITESPACE => true,
            _ => false,
        }
    }
}

{% for node, methods in ast %}
// {{ node }}
{% if not methods.enum%}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct {{ node }} {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for {{ node }} {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            {%- if methods.enum %}
            {% for kind in methods.enum %} | {{ kind | SCREAM }} {%- endfor -%}
            {% else %}
            {{ node | SCREAM }}
            {%- endif %} => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some({{ node }} { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
{% endif%}
{% if methods.enum %}
    #[derive(Debug, Clone, PartialEq, Eq,Hash)]
    pub enum {{ node }} {
        {%- for kind in methods.enum %}
            {{ kind }}({{ kind }}),
        {%- endfor %}
    }

    {%- for kind in methods.enum %}
        impl From<{{ kind }}> for {{ node }} {
            fn from(n: {{ kind }}) -> {{ node }} { 
                {{ node }}::{{kind}}(n)
            }
        }
    {%- endfor %}
impl AstNode for {{ node }} {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            {%- if methods.enum %}
            {% for kind in methods.enum %} | {{ kind | SCREAM }} {%- endfor -%}
            {% else %}
            {{ node | SCREAM }}
            {%- endif %} => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
            {% for kind in methods.enum %} 
            | {{ kind | SCREAM }}  => Some({{node}}::{{kind}}({{kind}} {syntax})),
            {%- endfor -%}
            _ => None
        }
    }
    fn syntax(&self) -> &SyntaxNode {  
        match self {
            {% for kind in methods.enum %} 
                {{node}}::{{ kind}}(kind)  => &kind.syntax,
            {%- endfor -%}
        }
    
    }
}
{% endif %}
{% if methods.traits -%}

{%- for t in methods.traits -%}
impl traits::{{ t }} for {{ node }} {}
{% endfor -%}

{%- endif -%}

impl {{ node }} {
{%- if methods.collections -%}
{%- for m in methods.collections -%}
{%- set method_name = m.0 -%}
{%- set ChildName = m.1 %}
    pub fn {{ method_name }}(&self) -> impl Iterator<Item = {{ ChildName }}> {
        children(self)
    }
{% endfor -%}
{%- endif -%}

{%- if methods.options -%}
{%- for m in methods.options -%}

{%- if m is string -%}
{%- set method_name = m | snake -%}
{%- set ChildName = m %}
{%- else -%}
{%- set method_name = m.0 -%}
{%- set ChildName = m.1 %}
{%- endif %}
    pub fn {{ method_name }}(&self) -> Option<{{ ChildName }}> {
        child_opt(self)
    }
{% endfor -%}
{%- endif -%}
}
{% endfor %}
